## Exame 2016

**1. a)**
```cpp
int greedy(const vector<int>& pos, const vector<int>& valor) {
    int totalValue = 0;
    int lastPlaced;

    for (int i = 0; i < pos.size(); ++i) {
        if (i == 0 || pos[i] - pos[lastPlaced] >= 5) {
            totalValue += valor[i];
            lastPlaced = i;
        }
    }

    return totalValue;
}
```
A complexidade temporal do algoritmo ganancioso é `O(n)`. O algoritmo não é ótimo visto que tenta incluir um cartaz sempre que puder, em vez de colocar os cartazes nos sítios que conduzem ao valor máximo.

**b)**
* Dados
    * Distância dos local i até ao fim do troço - vetor `pos[i]`
    * Valor do cartaz no local i - vetor `valor[i]`
    * Local mais próximo que está a uma distância maior ou igual a 5 km do local j - vetor `e[j]`
* Função objetivo
    * Maximizar `sum(valor[i] for i in locais)`
* Restrição
    * `pos[i] - pos[i - 1] >= 5 for i in range(1, locais.size())`

```cpp
int dynamic(const vector<int>& pos, const vector<int>& valor) {
    // TODO
}
```

**3. a)** Usando o algoritmo de Prim, começando no vértice A, este algoritmo mantém uma lista dos vértices conhecidos. Em cada passo do algoritmo, adiciona a aresta de menor peso que liga um vértice conhecido a um desconhecido. Ficamos com a seguinte árvore de expansão mínima (os vértices a vermelho mostram a ordem de exploração dos vértices):

![](Imagens/Prim2016.png)

**b)**  

**4. a)** O fluxo máximo é de 10000 uv, pelo que a rede não consegue transportar o volume desejado.

![](Imagens/Fluxo2016.jpg)

**b)** Permanece igual, visto que apenas 10000 uv conseguem atravessar o troço FA e atingir qualquer um dos consumidores.

**c)** O fluxo máximo passa a ser 30000 uv.

![](Imagens/Fluxo2016c.jpg)

**5. a)** Usando um código de tamanho fixo, o número de bits mínimo é dado pela expressão `ceil(log2(N))` onde N é o número de caracteres distintos na string. Como na string dada existem 9 caracteres distintos (`a, A, b, B, c, C, d, D, E`), 3 bits não seria suficiente para fazer a codificação. Seria necessário um código de `ceil(log2(9)) = 4` bits.  
**b)** A tabela de frequências do texto é:

Caracter|Frequência|Codificação binária
-|-|-
a|7|110
A|3|1011
b|5|000
B|2|1010
c|5|111
C|2|0010
d|8|01
D|2|0011
E|5|100

Usando o algoritmo de Huffman obtemos a seguinte árvore:

![](Imagens/Huffman2016.png)

Logo o custo mínimo da codificação será
```
(3 x 7) + (4 x 3) + (3 x 5) + (4 x 2) + (3 x 5) + (4 x 2) + (2 x 8) + (4 x 2) + (3 x 5)
= 21 + 12 + 15 + 8 + 15 + 8 + 16 + 8 + 15
= 118 bits
```

**c)** 

* Código de tamanho fixo: `39 x 4 = 156 bits`
* Código de tamaho variável: `118 bits`
* RLE: `32 bytes = 256 bits` (ASCII de 8 bits) ❓
    * String em RLE: `5a3b2C5d5E2D1d3A1a1b1c2d1b1a2B4c`

Logo o melhor método é a codificação de tamanho variável.

**6. a)**  